Sub ExternalSort(trxData As Variant)
    ' Assume trxData is a 2D array with TrxValue in the first column (index 1)

    Dim chunkSize As Long
    Dim numChunks As Long
    Dim i As Long

    ' Set the chunk size (adjust as needed)
    chunkSize = 10000  ' Choose an appropriate size

    ' Calculate the number of chunks
    numChunks = WorksheetFunction.Ceiling(UBound(trxData, 2) / chunkSize, 1)

    ' Sort each chunk in memory
    For i = 1 To numChunks
        Dim startIdx As Long
        Dim endIdx As Long

        startIdx = (i - 1) * chunkSize + 1
        endIdx = WorksheetFunction.Min(i * chunkSize, UBound(trxData, 2))

        ' Sort the chunk in memory
        SortArrayInMemory trxData, startIdx, endIdx
    Next i

    ' Merge the sorted chunks
    MergeSortedChunks trxData, chunkSize, numChunks
End Sub

Sub BubbleSort(trxData As Variant, startIdx As Long, endIdx As Long)
    Dim i As Long, j As Long
    Dim temp As Variant

    For i = startIdx To endIdx - 1
        For j = i + 1 To endIdx
            If trxData(1, i) > trxData(1, j) Then
                ' Swap values in the first column
                For k = LBound(trxData, 1) To UBound(trxData, 1)
                    temp = trxData(k, i)
                    trxData(k, i) = trxData(k, j)
                    trxData(k, j) = temp
                Next k
            End If
        Next j
    Next i
End Sub

Sub SortArrayInMemory(ByRef trxData As Variant, ByVal startIdx As Long, ByVal endIdx As Long)
    ' Sort a chunk of the array in memory (adjust sorting algorithm if needed)

    ' Assuming TrxValue is in the first column (index 1)
    SortArrayInMemory trxData, startIdx, endIdx

End Sub

Sub MergeSortedChunks(ByRef trxData As Variant, ByVal chunkSize As Long, ByVal numChunks As Long)
    ' Merge sorted chunks in memory (adjust merging algorithm if needed)

    Dim mergedData As Variant
    Dim i As Long

    ' Initialize mergedData
    ReDim mergedData(1 To UBound(trxData, 1), 1 To UBound(trxData, 2))

    ' Merge sorted chunks
    For i = 1 To numChunks
        Dim startIdx As Long
        Dim endIdx As Long

        startIdx = (i - 1) * chunkSize + 1
        endIdx = WorksheetFunction.Min(i * chunkSize, UBound(trxData, 2))

        ' Merge the current chunk into mergedData
        MergeArrays trxData, mergedData, startIdx, endIdx
    Next i

    ' Replace trxData with the mergedData
    trxData = mergedData
End Sub

Sub MergeArrays(ByRef sourceArray As Variant, ByRef destArray As Variant, ByVal startIdx As Long, ByVal endIdx As Long)
    ' Merge a portion of the sourceArray into the destArray

    Dim i As Long
    Dim j As Long

    For i = startIdx To endIdx
        For j = 1 To UBound(sourceArray, 1)
            destArray(j, i) = sourceArray(j, i)
        Next j
    Next i
End Sub


===========

Sub QuickSort(arr() As Variant, low As Long, high As Long)
    Dim i As Long, j As Long
    Dim pivot As Variant
    Dim temp As Variant

    If low < high Then
        pivot = arr(low, 1)
        i = low
        j = high

        Do
            Do While arr(i, 1) < pivot
                i = i + 1
            Loop

            Do While arr(j, 1) > pivot
                j = j - 1
            Loop

            If i <= j Then
                ' Swap elements
                For k = LBound(arr, 2) To UBound(arr, 2)
                    temp = arr(i, k)
                    arr(i, k) = arr(j, k)
                    arr(j, k) = temp
                Next k

                i = i + 1
                j = j - 1
            End If
        Loop While i <= j

        ' Recursively sort the two partitions
        QuickSort arr, low, j
        QuickSort arr, i, high
    End If
End Sub

Sub SortArray(arr() As Variant)
    QuickSort arr, LBound(arr, 1), UBound(arr, 1)
End Sub


=========
SELECT Event_map.[Event Name], Count(*) AS Samples, Min(Event_meter.Value) AS Minimum, Avg(Event_meter.Value) AS Average, Max(Event_meter.Value) AS Maximum, StDev(Event_meter.Value) AS [Standard Deviation], Sum(Event_meter.Value) AS TotalTime FROM TransactionEndStatus INNER JOIN (Event_map INNER JOIN Event_meter ON Event_map.[Event ID] = Event_meter.[Event ID]) ON TransactionEndStatus.Status1 = Event_meter.Status1 WHERE (((TransactionEndStatus.[Transaction End Status])="Pass")) GROUP BY Event_map.[Event Name] ORDER BY Sum(Event_meter.Value) DESC;


-====================================

import csv
import pyodbc
from collections import defaultdict
from openpyxl import Workbook

# Connect to the Access database using pyodbc
connection_string = r'DRIVER={Microsoft Access Driver (*.mdb)};DBQ=path\to\abcd.mdb;'
connection = pyodbc.connect(connection_string)
cursor = connection.cursor()

# Execute the query
query = "select trxName, TrxValue, trxStatus from Table1;"
cursor.execute(query)

# Fetch the data
data = cursor.fetchall()

# Close the database connection
connection.close()

# Process the fetched data
transactions = defaultdict(list)
fail_counts = defaultdict(int)

for row in data:
    trx_name, trx_value, trx_status = row.TrxName, row.TrxValue, row.TrxStatus

    if trx_status == 'PASS':
        transactions[trx_name].append(int(trx_value))
    elif trx_status == 'FAIL':
        fail_counts[trx_name] += 1

# Calculate and write results to Excel
wb = Workbook()
ws = wb.active

# Write headers
headers = ["TrxName", "Min", "Max", "Avg", "SelectedResponseTime", "PASS", "FAIL"]
ws.append(headers)

for trx_name, rt_values in transactions.items():
    if trx_name in fail_counts:
        fail_count = fail_counts[trx_name]
    else:
        fail_count = 0

    if rt_values:
        min_rt = min(rt_values)
        max_rt = max(rt_values)
        avg_rt = sum(rt_values) / len(rt_values)
        selected_rt_index = int((len(rt_values) - 1) * 0.9)
        selected_rt = sorted(rt_values)[selected_rt_index]
    else:
        min_rt = max_rt = avg_rt = selected_rt = 0

    pass_count = len(rt_values)

    ws.append([trx_name, min_rt, max_rt, avg_rt, selected_rt, pass_count, fail_count])

# Save the Excel file
wb.save('output.xlsx')


=====================================

import win32com.client
from collections import defaultdict
from openpyxl import Workbook

# Connection setup
db_path = r'C:\path\to\abcd.mdb'  # Replace with the actual path to your Access database file

# Connect to the Access database using win32com.client
try:
    # Create an instance of the Access application
    access_app = win32com.client.Dispatch("Access.Application")

    # Open the Access database
    access_db = access_app.DBEngine.OpenDatabase(db_path)

    # Execute your query and fetch the data
    query = "SELECT trxName, TrxValue, trxStatus FROM Table1;"
    data = access_db.QueryDefs["YourQueryName"].OpenRecordset().GetRows()

    # Process the fetched data and perform calculations
    transactions = defaultdict(list)
    fail_counts = defaultdict(int)

    for row in data:
        trx_name, trx_value, trx_status = row[0], row[1], row[2]

        if trx_status == 'PASS':
            transactions[trx_name].append(int(trx_value))
        elif trx_status == 'FAIL':
            fail_counts[trx_name] += 1

    # Calculate and write results to Excel
    wb = Workbook()
    ws = wb.active

    # Write headers
    headers = ["TrxName", "Min", "Max", "Avg", "SelectedResponseTime", "PASS", "FAIL"]
    ws.append(headers)

    for trx_name, rt_values in transactions.items():
        if trx_name in fail_counts:
            fail_count = fail_counts[trx_name]
        else:
            fail_count = 0

        if rt_values:
            min_rt = min(rt_values)
            max_rt = max(rt_values)
            avg_rt = sum(rt_values) / len(rt_values)
            selected_rt_index = int((len(rt_values) - 1) * 0.9)
            selected_rt = sorted(rt_values)[selected_rt_index]
        else:
            min_rt = max_rt = avg_rt = selected_rt = 0

        pass_count = len(rt_values)

        ws.append([trx_name, min_rt, max_rt, avg_rt, selected_rt, pass_count, fail_count])

    # Save the Excel file
    wb.save('output.xlsx')

    # Close the Access database
    access_db.Close()

except Exception as e:
    print(f"Error: {e}")

finally:
    # Quit the Access application
    access_app.Quit()

=======================

from collections import defaultdict
from openpyxl import Workbook
from mdbtools import mdb

# Connection setup
db_path = r'C:\path\to\abcd.mdb'  # Replace with the actual path to your Access database file

# Connect to the Access database using mdbtools
try:
    conn = mdb.connect(db_path)
    cursor = conn.cursor()

    # Execute your query and fetch the data
    query = "SELECT trxName, TrxValue, trxStatus FROM Table1;"
    cursor.execute(query)
    data = cursor.fetchall()

    # Process the fetched data and perform calculations
    transactions = defaultdict(list)
    fail_counts = defaultdict(int)

    for row in data:
        trx_name, trx_value, trx_status = row[0], row[1], row[2]

        if trx_status == 'PASS':
            transactions[trx_name].append(int(trx_value))
        elif trx_status == 'FAIL':
            fail_counts[trx_name] += 1

    # Calculate and write results to Excel
    wb = Workbook()
    ws = wb.active

    # Write headers
    headers = ["TrxName", "Min", "Max", "Avg", "SelectedResponseTime", "PASS", "FAIL"]
    ws.append(headers)

    for trx_name, rt_values in transactions.items():
        if trx_name in fail_counts:
            fail_count = fail_counts[trx_name]
        else:
            fail_count = 0

        if rt_values:
            min_rt = min(rt_values)
            max_rt = max(rt_values)
            avg_rt = sum(rt_values) / len(rt_values)
            selected_rt_index = int((len(rt_values) - 1) * 0.9)
            selected_rt = sorted(rt_values)[selected_rt_index]
        else:
            min_rt = max_rt = avg_rt = selected_rt = 0

        pass_count = len(rt_values)

        ws.append([trx_name, min_rt, max_rt, avg_rt, selected_rt, pass_count, fail_count])

    # Save the Excel file
    wb.save('output.xlsx')

    # Close the database connection
    conn.close()

except Exception as e:
    print(f"Error: {e}")

===========================

def find_90th_value(numbers):
    # Sort the list in ascending order
    numbers.sort()

    # Calculate the index for the 90th value
    index_90th = int(0.9 * len(numbers)) - 1

    # Retrieve and return the 90th value
    value_90th = numbers[index_90th]
    return value_90th

# Example usage:
try:
    # Input comma-separated numbers from the user
    input_numbers = input("Enter a list of numbers separated by commas: ")

    # Convert input string to a list of integers
    numbers = [int(num) for num in input_numbers.split(',')]

    # Find and print the 90th value
    result = find_90th_value(numbers)
    print(f"The 90th value is: {result}")

except ValueError:
    print("Invalid input. Please enter a list of numbers separated by commas.")



import csv
from collections import defaultdict

# Sample data
data = """trxName,RT
A,1
A,3
A,5
A,2
A,7
B,9
B,2
B,1
B,3
B,5
B,2
B,7
B,12"""

# Convert the sample data to a list of dictionaries
reader = csv.DictReader(data.splitlines())
transactions = list(reader)

# Group data by transaction name
grouped_data = defaultdict(list)
for entry in transactions:
    grouped_data[entry['trxName']].append(int(entry['RT']))

# Calculate and print the results
print("TrxName,Min,Max,Count,Avg,90thResponseTime")

for trx_name, values in grouped_data.items():
    values.sort()
    count = len(values)
    minimum = min(values)
    maximum = max(values)
    average = sum(values) / count
    ninetieth_percentile_index = int(0.9 * count) - 1
    ninetieth_response_time = values[ninetieth_percentile_index]

    print(f"{trx_name},{minimum},{maximum},{count},{average:.2f},{ninetieth_response_time}")

==========================

pip install pyodbc openpyxl
import pyodbc
from openpyxl import Workbook

# Connect to the Access database
connection_string = r'DRIVER={Microsoft Access Driver (*.mdb, *.accdb)};DBQ=path_to_your_access_db.accdb;'
conn = pyodbc.connect(connection_string)
cursor = conn.cursor()

# Sample queries
queries = [
    "SELECT * FROM Table1",
    "SELECT * FROM Table2",
    "SELECT * FROM Table3"
]

# Create an Excel workbook and sheets
wb = Workbook()
sheets = [wb.create_sheet(title=f"Sheet_{i + 1}") for i in range(len(queries))]

# Execute queries and write results to Excel sheets
for i, query in enumerate(queries):
    sheet = sheets[i]

    # Execute the query
    cursor.execute(query)

    # Write column names to the Excel sheet
    columns = [column[0] for column in cursor.description]
    sheet.append(columns)

    # Write data to the Excel sheet
    for row in cursor.fetchall():
        sheet.append(row)

# Save the Excel workbook
wb.save('output.xlsx')

# Close the database connection
cursor.close()
conn.close()


=========================

import pyodbc
from openpyxl import Workbook

# Connection string for Access database
conn_str = r'DRIVER={Microsoft Access Driver (*.mdb)};DBQ=C:\path\to\your\database.mdb;'

# Function to execute a query and return results
def execute_query(connection, query):
    cursor = connection.cursor()
    cursor.execute(query)
    columns = [column[0] for column in cursor.description]
    rows = cursor.fetchall()
    return columns, rows

# Function to export data to Excel sheet
def export_to_excel(workbook, sheet_name, columns, rows):
    sheet = workbook.create_sheet(title=sheet_name)
    
    # Write column headers
    for col_num, col_name in enumerate(columns, 1):
        sheet.cell(row=1, column=col_num, value=col_name)

    # Write data rows
    for row_num, row_data in enumerate(rows, 2):
        for col_num, cell_value in enumerate(row_data, 1):
            sheet.cell(row=row_num, column=col_num, value=cell_value)

# Main function
def main():
    # Connect to the Access database
    connection = pyodbc.connect(conn_str)

    # Example queries
    query1 = 'SELECT * FROM Table1'
    query2 = 'SELECT * FROM Table2'

    # Create an Excel workbook
    workbook = Workbook()

    # Execute queries and export results to Excel
    for query_num, query in enumerate([query1, query2], 1):
        sheet_name = f'Sheet{query_num}'
        columns, rows = execute_query(connection, query)
        export_to_excel(workbook, sheet_name, columns, rows)

    # Save the Excel workbook
    workbook.save('output.xlsx')

    # Close the database connection
    connection.close()

if __name__ == "__main__":
    main()


=======================

import re

# Sample HTML content
html_content = """
<html>
<head>
    <title>Sample HTML</title>
</head>
<body>
    <div class="content">
        <h1>Page Title</h1>
        <p class="paragraph">This is a sample paragraph.</p>
        <table>
            <tr>
                <th>Header 1</th>
                <th>Header 2</th>
                <th>Header 3</th>
            </tr>
            <tr>
                <td>Row 1 Col 1</td>
                <td>Row 1 Col 2</td>
                <td>Row 1 Col 3</td>
            </tr>
            <tr>
                <td>Row 2 Col 1</td>
                <td>Row 2 Col 2</td>
                <td>Row 2 Col 3</td>
            </tr>
        </table>
    </div>
</body>
</html>
"""

# Extract data using regular expressions
page_title = re.search(r'<title>(.*?)</title>', html_content).group(1)
paragraph_text = re.search(r'<p class="paragraph">(.*?)</p>', html_content).group(1)

table_match = re.search(r'<table>.*?</table>', html_content, re.DOTALL)
table_content = table_match.group() if table_match else ''

# Extract data from the table using regular expressions
table_headers = re.findall(r'<th>(.*?)</th>', table_content)
table_rows = re.findall(r'<tr>.*?<td>(.*?)</td>.*?<td>(.*?)</td>.*?<td>(.*?)</td>.*?</tr>', table_content, re.DOTALL)

# Print the extracted data
print("Page Title:", page_title)
print("Paragraph Text:", paragraph_text)

print("\nTable Headers:", table_headers)
print("Table Rows:")
for row in table_rows:
    print(row)


===================================

import re
from openpyxl import Workbook

# Sample HTML content
html_content = """
<html>
<head>
    <title>Sample HTML</title>
</head>
<body>
    <div class="content">
        <h1>Page Title</h1>
        <p class="paragraph">This is a sample paragraph.</p>
        <table>
            <tr>
                <th>Header 1</th>
                <th>Header 2</th>
                <th>Header 3</th>
            </tr>
            <tr>
                <td>Row 1 Col 1</td>
                <td>Row 1 Col 2</td>
                <td>Row 1 Col 3</td>
            </tr>
            <tr>
                <td>Row 2 Col 1</td>
                <td>Row 2 Col 2</td>
                <td>Row 2 Col 3</td>
            </tr>
        </table>
    </div>
</body>
</html>
"""

# Create Excel workbook
workbook = Workbook()
sheet = workbook.active

# Extract data using regular expressions
page_title = re.search(r'<title>(.*?)</title>', html_content).group(1)
paragraph_text = re.search(r'<p class="paragraph">(.*?)</p>', html_content).group(1)

table_match = re.search(r'<table>.*?</table>', html_content, re.DOTALL)
table_content = table_match.group() if table_match else ''

# Extract data from the table using regular expressions
table_headers = re.findall(r'<th>(.*?)</th>', table_content)
table_rows = re.findall(r'<tr>.*?<td>(.*?)</td>.*?<td>(.*?)</td>.*?<td>(.*?)</td>.*?</tr>', table_content, re.DOTALL)

# Write data to Excel sheet
sheet['A1'] = 'Page Title'
sheet['B1'] = 'Paragraph Text'
sheet['A2'] = page_title
sheet['B2'] = paragraph_text

# Write table headers
for col_num, header in enumerate(table_headers, start=1):
    sheet.cell(row=4, column=col_num, value=header)

# Write table rows
for row_num, row_data in enumerate(table_rows, start=5):
    for col_num, cell_value in enumerate(row_data, start=1):
        sheet.cell(row=row_num, column=col_num, value=cell_value)

# Save the Excel workbook
workbook.save('output.xlsx')


==================

import openpyxl
import pyodbc

def execute_query(connection, query, granularity):
    cursor = connection.cursor()
    cursor.execute(query, {"Granularity": granularity})
    result = cursor.fetchall()
    cursor.close()
    return result

def write_to_excel(result, sheet_name, workbook):
    sheet = workbook.create_sheet(title=sheet_name)

    # Write header
    header = [column[0] for column in result.description]
    sheet.append(header)

    # Write data
    for row in result:
        sheet.append(row)

def main():
    # Access database connection string
    conn_str = r"DRIVER={Microsoft Access Driver (*.mdb, *.accdb)};DBQ=C:\path\to\your\database.accdb;"
    connection = pyodbc.connect(conn_str)

    # Customizable granularity
    granularity = 10  # Replace with your desired granularity

    # Query template
    query_template = """
    SELECT 
        Sum([inout flag]) AS [SumAll],
        ( ( ( Floor(( [end time] - 0 ) / ?) ) * ? ) + 0 ) AS [Granu],
        [vuser status name]
    FROM   
        (vuserevent_meter
            INNER JOIN vuserstatus
                ON ( vuserevent_meter.[vuser status id] = vuserstatus.[vuser status id] ))
    WHERE  
        (( [vuser status name] = 'Run' ))
    GROUP  BY 
        ( ( ( Floor(( [end time] - 0 ) / ?) ) * ? ) + 0 ),
        [vuser status name]
    ORDER  BY 
        [vuser status name],
        ( ( ( Floor(( [end time] - 0 ) / ?) ) * ? ) + 0 );
    """

    # Execute query and write to Excel
    workbook = openpyxl.Workbook()

    result = execute_query(connection, query_template, granularity)
    write_to_excel(result, "Sheet1", workbook)

    # Save the Excel file
    workbook.save("output.xlsx")

    # Close the database connection
    connection.close()

if __name__ == "__main__":
    main()


===================================================


Sub RunPythonScript()
    Dim objShell As Object
    Set objShell = VBA.CreateObject("WScript.Shell")

    ' Set the path to your Python executable and script
    pythonScript = "C:\path\to\your\python.exe C:\path\to\your\script.py"

    ' Set your parameters
    startTime = "2024-01-01"
    endTime = "2024-02-01"
    mdbFileLocation = "C:\path\to\your\abcd.mdb"

    ' Concatenate parameters to the script
    parameters = " " & startTime & " " & endTime & " " & mdbFileLocation

    ' Run the Python script with parameters
    objShell.Run pythonScript & parameters, 1, True

    ' Optionally, add code here to refresh or manipulate Excel data based on script output
End Sub



=======================================

import os
import zipfile
import requests
import openpyxl
import datetime
import subprocess
import pywin32com.client as win32

def read_config_from_excel(file_path):
    wb = openpyxl.load_workbook(file_path)
    sheet = wb.active

    # Read configuration parameters from cells A2, D2, C2, F2
    start_time = sheet['A2'].value
    end_time = sheet['D2'].value
    mdb_file_location = sheet['C2'].value
    destination_folder = sheet['F2'].value

    return start_time, end_time, mdb_file_location, destination_folder

def download_and_unzip_from_api(api_url, destination_folder):
    # Download zip folder from API
    response = requests.get(api_url)

    # Save zip file
    zip_file_path = os.path.join(destination_folder, 'downloaded_data.zip')
    with open(zip_file_path, 'wb') as zip_file:
        zip_file.write(response.content)

    # Unzip the folder
    with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
        zip_ref.extractall(destination_folder)

    return destination_folder

def execute_access_queries(mdb_file_location, queries):
    # Your code to execute Access queries and write to Excel sheets
    pass

def execute_dynatrace_api_queries(api_urls, excel_file, sheet_names):
    # Your code to execute Dynatrace API queries and write to Excel sheets
    pass

def run_excel_macro(excel_file, macro_name):
    xl = win32.Dispatch("Excel.Application")
    xl.Visible = False

    wb = xl.Workbooks.Open(excel_file)
    xl.Application.Run(f"{excel_file}!{macro_name}")

    wb.Save()
    xl.Quit()

def main():
    # Read configuration from Excel
    excel_file_path = 'config.xlsx'
    start_time, end_time, mdb_file_location, destination_folder = read_config_from_excel(excel_file_path)

    # Download and unzip data from API
    api_url = 'https://example.com/api/data.zip'
    download_and_unzip_from_api(api_url, destination_folder)

    # Execute Access queries
    access_queries = ['SELECT * FROM Table1;', 'SELECT * FROM Table2;']
    execute_access_queries(mdb_file_location, access_queries)

    # Execute Dynatrace API queries
    dynatrace_api_urls = ['https://dynatrace-api.com/query1', 'https://dynatrace-api.com/query2']
    dynatrace_sheet_names = ['DynatraceSheet1', 'DynatraceSheet2']
    execute_dynatrace_api_queries(dynatrace_api_urls, excel_file_path, dynatrace_sheet_names)

    # Run Excel macro for consolidation
    macro_name = 'ConsolidateData'
    run_excel_macro(excel_file_path, macro_name)

if __name__ == "__main__":
    main()


import pyodbc
from openpyxl import Workbook

def execute_access_queries(mdb_file_location, queries, excel_file):
    connection_string = f'DRIVER={{Microsoft Access Driver (*.mdb, *.accdb)}};DBQ={mdb_file_location};'
    
    try:
        connection = pyodbc.connect(connection_string)
        cursor = connection.cursor()

        # Create a new workbook to write query results
        wb = Workbook()

        for i, query in enumerate(queries):
            sheet_name = f'QueryResult_{i + 1}'
            ws = wb.create_sheet(title=sheet_name)

            # Execute the query
            cursor.execute(query)
            rows = cursor.fetchall()

            # Write query result to the sheet
            header_row = [column[0] for column in cursor.description]
            ws.append(header_row)

            for row in rows:
                ws.append(row)

        # Save the workbook to the specified Excel file
        wb.save(excel_file)

    except pyodbc.Error as e:
        print(f"Error: {e}")

    finally:
        if connection:
            connection.close()

# Example usage:
access_queries = ['SELECT * FROM Table1;', 'SELECT * FROM Table2;']
execute_access_queries(mdb_file_location, access_queries, 'access_query_results.xlsx')



=====================


Sub RunPythonScript()
    Dim objShell As Object
    Dim pythonPath As String
    Dim scriptPath As String
    Dim mdbFileLocation As String
    Dim startTime As String
    Dim endTime As String
    Dim output As String
    
    ' Set your Python executable path
    pythonPath = "C:\Path\To\Your\Python\python.exe"
    
    ' Set your Python script path
    scriptPath = "C:\Path\To\Your\Python\script.py"
    
    ' Get parameters from Excel cells
    mdbFileLocation = Worksheets("Sheet1").Range("B2").Value
    startTime = Worksheets("Sheet1").Range("B3").Value
    endTime = Worksheets("Sheet1").Range("B4").Value
    
    ' Check if parameters are provided
    If Len(mdbFileLocation) = 0 Or Len(startTime) = 0 Or Len(endTime) = 0 Then
        MsgBox "Please enter all parameters.", vbExclamation
        Exit Sub
    End If
    
    ' Construct the command to run the Python script
    command = pythonPath & " " & scriptPath & " " & startTime & " " & endTime & " " & mdbFileLocation
    
    ' Create a Shell object
    Set objShell = VBA.CreateObject("WScript.Shell")
    
    ' Run the Python script and capture the output
    output = objShell.Exec(command).StdOut.ReadAll
    
    ' Write the output to Sheet1 in Excel
    Worksheets("Sheet1").Cells.Clear
    Worksheets("Sheet1").Range("A1").Value = output
End Sub


========


Sub ProcessTransactions()
    Dim lastRow As Long
    Dim trxName As String
    Dim rtValues() As Double
    Dim passCount As Long
    Dim failCount As Long
    Dim minRT As Double
    Dim maxRT As Double
    Dim avgRT As Double
    Dim perc90RT As Double
    Dim i As Long

    ' Assuming your data starts from A2 and has headers in the first row
    lastRow = Cells(Rows.Count, 1).End(xlUp).Row

    ' Initialize summary table headers
    Cells(1, 7).Value = "TrxName"
    Cells(1, 8).Value = "Min"
    Cells(1, 9).Value = "Max"
    Cells(1, 10).Value = "Avg"
    Cells(1, 11).Value = "90thResponseTime"
    Cells(1, 12).Value = "PASS"
    Cells(1, 13).Value = "FAIL"

    ' Initialize variables
    trxName = Cells(2, 1).Value
    passCount = 0
    failCount = 0

    ' Execute your MDB query here and populate the dataset
    ' For example, replace "YourQueryName" with your actual query name
    ' Dim rs As Object
    ' Set rs = CurrentDb.OpenRecordset("YourQueryName")

    ' Loop through the dataset
    For i = 2 To lastRow
        ' Assuming "rs" is your recordset
        ' If Not rs.EOF Then
        '     trxName = rs.Fields("trxName").Value
        '     If trxName <> rs.Fields("trxName").Value Then
        '         ' Process summary for the previous transaction
        '         ProcessTransactionSummary trxName, rtValues, passCount, failCount

        '         ' Reset variables for the new transaction
        '         trxName = rs.Fields("trxName").Value
        '         passCount = 0
        '         failCount = 0
        '         ReDim rtValues(1 To 1)
        '     End If

        '     If rs.Fields("Status").Value = "PASS" Then
        '         passCount = passCount + 1
        '         ReDim Preserve rtValues(1 To passCount)
        '         rtValues(passCount) = rs.Fields("RT").Value
        '     ElseIf rs.Fields("Status").Value = "FAIL" Then
        '         failCount = failCount + 1
        '     End If

        '     rs.MoveNext
        ' End If
    Next i

    ' Close the recordset
    ' rs.Close

    ' Process summary for the last transaction
    ProcessTransactionSummary trxName, rtValues, passCount, failCount
End Sub

Sub ProcessTransactionSummary(trxName As String, rtValues() As Double, passCount As Long, failCount As Long)
    Dim minRT As Double
    Dim maxRT As Double
    Dim avgRT As Double
    Dim perc90RT As Double
    Dim i As Long

    If passCount > 0 Then
        ' Sort rtValues in ascending order
        SortArray rtValues

        ' Calculate summary statistics
        minRT = rtValues(1)
        maxRT = rtValues(passCount)
        avgRT = WorksheetFunction.Average(rtValues)
        perc90RT = rtValues(Application.RoundUp(0.9 * passCount, 0))

        ' Output summary to the next available row
        Dim nextRow As Long
        nextRow = Cells(Rows.Count, 7).End(xlUp).Row + 1
        Cells(nextRow, 7).Value = trxName
        Cells(nextRow, 8).Value = minRT
        Cells(nextRow, 9).Value = maxRT
        Cells(nextRow, 10).Value = avgRT
        Cells(nextRow, 11).Value = perc90RT
        Cells(nextRow, 12).Value = passCount
        Cells(nextRow, 13).Value = failCount
    End If
End Sub

Sub SortArray(arr() As Double)
    Dim i As Long, j As Long
    Dim temp As Double

    For i = LBound(arr) To UBound(arr) - 1
        For j = i + 1 To UBound(arr)
            If arr(i) > arr(j) Then
                temp = arr(i)
                arr(i) = arr(j)
                arr(j) = temp
            End If
        Next j
    Next i
End Sub


=====

Sub ProcessTransactions()
    Dim lastRow As Long
    Dim trxName As String
    Dim rtValues() As Double
    Dim passCount As Long
    Dim failCount As Long
    Dim minRT As Double
    Dim maxRT As Double
    Dim avgRT As Double
    Dim perc90RT As Double
    Dim i As Long

    ' Assuming your data starts from A2 and has headers in the first row
    lastRow = Cells(Rows.Count, 1).End(xlUp).Row

    ' Initialize summary table headers
    Cells(1, 7).Value = "TrxName"
    Cells(1, 8).Value = "Min"
    Cells(1, 9).Value = "Max"
    Cells(1, 10).Value = "Avg"
    Cells(1, 11).Value = "90thResponseTime"
    Cells(1, 12).Value = "PASS"
    Cells(1, 13).Value = "FAIL"

    ' Initialize variables
    trxName = Cells(2, 1).Value
    passCount = 0
    failCount = 0

    For i = 2 To lastRow
        If trxName <> Cells(i, 1).Value Then
            ' Process summary for the previous transaction
            ProcessTransactionSummary trxName, rtValues, passCount, failCount

            ' Reset variables for the new transaction
            trxName = Cells(i, 1).Value
            passCount = 0
            failCount = 0
            ReDim rtValues(1 To 1)
        End If

        If Cells(i, 3).Value = "PASS" Then
            passCount = passCount + 1
            ReDim Preserve rtValues(1 To passCount)
            rtValues(passCount) = Cells(i, 2).Value
        ElseIf Cells(i, 3).Value = "FAIL" Then
            failCount = failCount + 1
        End If
    Next i

    ' Process summary for the last transaction
    ProcessTransactionSummary trxName, rtValues, passCount, failCount
End Sub

Sub ProcessTransactionSummary(trxName As String, rtValues() As Double, passCount As Long, failCount As Long)
    Dim minRT As Double
    Dim maxRT As Double
    Dim avgRT As Double
    Dim perc90RT As Double
    Dim i As Long

    If passCount > 0 Then
        ' Sort rtValues in ascending order
        SortArray rtValues

        ' Calculate summary statistics
        minRT = rtValues(1)
        maxRT = rtValues(passCount)
        avgRT = WorksheetFunction.Average(rtValues)
        perc90RT = rtValues(Application.RoundUp(0.9 * passCount, 0))

        ' Output summary to the next available row
        Dim nextRow As Long
        nextRow = Cells(Rows.Count, 7).End(xlUp).Row + 1
        Cells(nextRow, 7).Value = trxName
        Cells(nextRow, 8).Value = minRT
        Cells(nextRow, 9).Value = maxRT
        Cells(nextRow, 10).Value = avgRT
        Cells(nextRow, 11).Value = perc90RT
        Cells(nextRow, 12).Value = passCount
        Cells(nextRow, 13).Value = failCount
    End If
End Sub

Sub SortArray(arr() As Double)
    Dim i As Long, j As Long
    Dim temp As Double

    For i = LBound(arr) To UBound(arr) - 1
        For j = i + 1 To UBound(arr)
            If arr(i) > arr(j) Then
                temp = arr(i)
                arr(i) = arr(j)
                arr(j) = temp
            End If
        Next j
    Next i
End Sub


====
Sub ProcessTransactionsWithData(trxData As Variant)
    Dim lastRow As Long
    Dim trxName As String
    Dim rtValues() As Double
    Dim passCount As Long
    Dim failCount As Long
    Dim minRT As Double
    Dim maxRT As Double
    Dim avgRT As Double
    Dim perc90RT As Double
    Dim i As Long

    ' Initialize summary table headers
    Cells(1, 7).Value = "TrxName"
    Cells(1, 8).Value = "Min"
    Cells(1, 9).Value = "Max"
    Cells(1, 10).Value = "Avg"
    Cells(1, 11).Value = "90thResponseTime"
    Cells(1, 12).Value = "PASS"
    Cells(1, 13).Value = "FAIL"

    ' Initialize variables
    trxName = trxData(2, 1)
    passCount = 0
    failCount = 0

    For i = 2 To UBound(trxData, 1)
        If trxName <> trxData(i, 1) Then
            ' Process summary for the previous transaction
            ProcessTransactionSummary trxName, rtValues, passCount, failCount

            ' Reset variables for the new transaction
            trxName = trxData(i, 1)
            passCount = 0
            failCount = 0
            ReDim rtValues(1 To 1)
        End If

        If trxData(i, 3) = "PASS" Then
            passCount = passCount + 1
            ReDim Preserve rtValues(1 To passCount)
            rtValues(passCount) = trxData(i, 2)
        ElseIf trxData(i, 3) = "FAIL" Then
            failCount = failCount + 1
        End If
    Next i

    ' Process summary for the last transaction
    ProcessTransactionSummary trxName, rtValues, passCount, failCount
End Sub

Sub ProcessTransactionSummary(trxName As String, rtValues() As Double, passCount As Long, failCount As Long)
    Dim minRT As Double
    Dim maxRT As Double
    Dim avgRT As Double
    Dim perc90RT As Double
    Dim i As Long

    If passCount > 0 Then
        ' Sort rtValues in ascending order
        SortArray rtValues

        ' Calculate summary statistics
        minRT = rtValues(1)
        maxRT = rtValues(passCount)
        avgRT = WorksheetFunction.Average(rtValues)
        perc90RT = rtValues(Application.RoundUp(0.9 * passCount, 0))

        ' Output summary to the next available row
        Dim nextRow As Long
        nextRow = Cells(Rows.Count, 7).End(xlUp).Row + 1
        Cells(nextRow, 7).Value = trxName
        Cells(nextRow, 8).Value = minRT
        Cells(nextRow, 9).Value = maxRT
        Cells(nextRow, 10).Value = avgRT
        Cells(nextRow, 11).Value = perc90RT
        Cells(nextRow, 12).Value = passCount
        Cells(nextRow, 13).Value = failCount
    End If
End Sub

Sub SortArray(arr() As Double)
    Dim i As Long, j As Long
    Dim temp As Double

    For i = LBound(arr) To UBound(arr) - 1
        For j = i + 1 To UBound(arr)
            If arr(i) > arr(j) Then
                temp = arr(i)
                arr(i) = arr(j)
                arr(j) = temp
            End If
        Next j
    Next i
End Sub


Sub YourMainMacro()
    ' Execute the MDB query and get the data into a 2D array
    Dim mdbData As Variant
    ' ... Code to execute query and load data into mdbData ...

    ' Pass the dataset to the processing function
    ProcessTransactionsWithData mdbData
End Sub
